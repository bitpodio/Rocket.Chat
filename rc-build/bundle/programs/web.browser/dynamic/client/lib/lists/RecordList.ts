function module(t,e,i){let s,h,r,a;i.link("@babel/runtime/helpers/classPrivateFieldLooseBase",{default(t){s=t}},0),i.link("@babel/runtime/helpers/classPrivateFieldLooseKey",{default(t){h=t}},1),i.export({RecordList:()=>m}),i.link("@rocket.chat/emitter",{Emitter(t){r=t}},0),i.link("../asyncState",{AsyncStatePhase(t){a=t}},1);var n=h("hasChanges"),o=h("index"),d=h("phase"),u=h("items"),l=h("itemCount"),c=h("pedingMutation");class m extends r{constructor(){super(...arguments),Object.defineProperty(this,n,{writable:!0,value:void 0}),Object.defineProperty(this,o,{writable:!0,value:void 0}),Object.defineProperty(this,d,{writable:!0,value:void 0}),Object.defineProperty(this,u,{writable:!0,value:void 0}),Object.defineProperty(this,l,{writable:!0,value:void 0}),Object.defineProperty(this,c,{writable:!0,value:void 0}),s(this,n)[n]=!1,s(this,o)[o]=new Map,s(this,d)[d]=a.LOADING,s(this,u)[u]=void 0,s(this,l)[l]=void 0,s(this,c)[c]=Promise.resolve()}filter(t){return!0}compare(t,e){return t._updatedAt.getTime()-e._updatedAt.getTime()}get phase(){return s(this,d)[d]}get items(){return s(this,u)[u]||(s(this,u)[u]=Array.from(s(this,o)[o].values()).sort(this.compare)),s(this,u)[u]}get itemCount(){var t;return null!==(t=s(this,l)[l])&&void 0!==t?t:s(this,o)[o].size}insert(t){s(this,o)[o].set(t._id,t),this.emit("".concat(t._id,"/inserted"),t),"number"==typeof s(this,l)[l]&&s(this,l)[l]++,s(this,n)[n]=!0}update(t){s(this,o)[o].set(t._id,t),this.emit("".concat(t._id,"/updated"),t),s(this,n)[n]=!0}delete(t){s(this,o)[o].delete(t),this.emit("".concat(t,"/deleted")),"number"==typeof s(this,l)[l]&&s(this,l)[l]--,s(this,n)[n]=!0}push(t){const e=s(this,o)[o].has(t._id),i=this.filter(t);!e||i?e&&i?this.update(t):!e&&i&&this.insert(t):this.delete(t._id)}async mutate(t){try{s(this,d)[d]===a.RESOLVED&&(s(this,d)[d]=a.UPDATING,this.emit("mutating")),s(this,c)[c]=s(this,c)[c].then(t),await s(this,c)[c]}catch(e){this.emit("errored",e)}finally{const t=s(this,n)[n];s(this,d)[d]=a.RESOLVED,t&&(s(this,u)[u]=void 0,s(this,n)[n]=!1),this.emit("mutated",t)}}batchHandle(t){return this.mutate(async()=>{const e=await t();if(e.items)for(const t of e.items)this.push(t);e.itemCount&&(s(this,l)[l]=e.itemCount,s(this,n)[n]=!0)})}prune(t){return this.mutate(()=>{for(const e of s(this,o)[o].values())t(e)&&this.delete(e._id)})}handle(t){return this.mutate(()=>{this.push(t)})}remove(t){return this.mutate(()=>{s(this,o)[o].has(t)&&this.delete(t)})}clear(){return this.mutate(()=>{0!==s(this,o)[o].size&&(s(this,o)[o].clear(),s(this,u)[u]=void 0,s(this,l)[l]=void 0,s(this,n)[n]=!0,this.emit("cleared"))})}}}

